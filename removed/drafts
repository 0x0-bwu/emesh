bool MeshFlow3D::ExtractTopology(StackLayerPolygons & polygons, const std::vector<StackLayerInfo> & infos, const InterfaceIntersections & intersections,
                                 std::vector<Point3D<coor_t> > & points, std::list<IndexEdge> & edges)
{
    points.clear();
    edges.clear();
    if(polygons.size() != infos.size()) return false;

    using EdgeSet = topology::UndirectedIndexEdgeSet;
    using LayerIdxMap = std::unordered_map<coor_t, size_t>;
    using PointIdxMap = std::unordered_map<Point2D<coor_t>, size_t, PointHash<coor_t> >;
    using LayerPointIdxMap = std::vector<PointIdxMap>;
    
    EdgeSet edgeSet;
    std::vector<coor_t> heights(infos.size() + 1);
    LayerPointIdxMap lyrPtIdxMap(infos.size() + 1);
    size_t lyrIdx = 0;
    for(const auto & info : infos){
        heights[lyrIdx] = info.elevation;
        lyrIdx++;
    }
    heights[lyrIdx] = infos.back().elevation - infos.back().thickness;

    auto getIndex = [&lyrPtIdxMap, &heights, &points](const Point2D<coor_t> & p, size_t layer) mutable
    {
        auto & ptIdxMap = lyrPtIdxMap[layer];
        if(!ptIdxMap.count(p)){
            auto index = points.size();
            ptIdxMap.insert(std::make_pair(p, index));
            points.push_back(Point3D<coor_t>(p[0], p[1], heights[layer]));
        }
        return ptIdxMap.at(p);
    };

    lyrIdx = 0;
    const auto & top = polygons.front();
    for(const auto & polygon : top){
        auto size = polygon.Size();
        for(size_t i = 0; i < size; ++i){
            size_t j = (i + 1) % size;
            IndexEdge e(getIndex(polygon[i], lyrIdx), getIndex(polygon[j], lyrIdx));
            if(edgeSet.count(e)) continue;
            edgeSet.insert(e);
            edges.emplace_back(std::move(e)); 
        }
    }
    
    for(const auto & intersection : intersections){
        lyrIdx++;
        for(const auto & segment : intersection){
            IndexEdge e(getIndex(segment[0], lyrIdx), getIndex(segment[1], lyrIdx));
            if(edgeSet.count(e)) continue;
            edgeSet.insert(e);
            edges.emplace_back(std::move(e));
        }
    }

    lyrIdx++;
    const auto & bot = polygons.back();
    for(const auto & polygon : bot){
        auto size = polygon.Size();
        for(size_t i = 0; i < size; ++i){
            size_t j = (i + 1) % size;
            IndexEdge e(getIndex(polygon[i], lyrIdx), getIndex(polygon[j], lyrIdx));
            if(edgeSet.count(e)) continue;
            edgeSet.insert(e);
            edges.emplace_back(std::move(e)); 
        }
    }

    lyrIdx = 0;
    for(const auto & layer : polygons){
        for(const auto & polygon : layer){
            size_t size = polygon.Size();
            for(size_t i = 0; i < size; ++i){
                IndexEdge e(getIndex(polygon[i], lyrIdx), getIndex(polygon[i], lyrIdx + 1));
                if(edgeSet.count(e)) continue;
                edgeSet.insert(e);
                edges.emplace_back(std::move(e)); 
            }
        }
        lyrIdx++;
    }
    return true;
}

bool ImportMeshCtrlFile(const std::string & txt, Mesh2Ctrl & ctrl)
{
    std::ifstream in(txt);
    if(!in.is_open()) return false;

    std::string line, tmp;
    float_t scale(0), tolerance(0), maxEdge(0), minEdge(0), minAlpha(0);
    while(!in.eof()){
        line.clear();
        std::getline(in, line);
        if(line.empty()) continue;
        if(0 == line.rfind("Tolerance", 0)){
            std::stringstream ss(line);
            ss.ignore(std::string("Tolerance (um) = ").size());
            ss >> tolerance;
        }
        if(0 == line.rfind("Max Edge Length")){
            std::stringstream ss(line);
            ss.ignore(std::string("Max Edge Length (um) = ").size());
            ss >> maxEdge;
        }
        if(0 == line.rfind("QualityTarget")){
            std::stringstream ss(line);
            ss.ignore(std::string("QualityTarget = ").size());
            ss >> minAlpha >> minEdge;
        }
    }

    //validation
    if(0 < tolerance) {
        ctrl.scale2Int = 10 / tolerance;
        ctrl.tolerance = tolerance * ctrl.scale2Int;

        if(0 < minAlpha) ctrl.minAlpha = math::Rad(minAlpha);
        if(0 < maxEdge) ctrl.maxEdgeLen = maxEdge * ctrl.scale2Int;
        if(0 < minEdge) ctrl.minEdgeLen = minEdge * ctrl.scale2Int;
    }
    in.close();
    return true;
}

bool MeshFileUtility::LoadWktFile(const std::string & wkt, float_t scale, PolygonContainer & polygons)
{
    polygons.clear();
    std::list<Polygon2D<float_t> > tmp;
    if(!geometry::GeometryIO::Read<Polygon2D<float_t> >(wkt, std::back_inserter(tmp))) return false;

    auto trans = makeScaleTransform2D(scale);
    for(const auto & t : tmp){
        auto ts = trans * t;
        polygons.emplace_back(std::move(ts.Cast<coor_t>()));
    }
    return true;
}